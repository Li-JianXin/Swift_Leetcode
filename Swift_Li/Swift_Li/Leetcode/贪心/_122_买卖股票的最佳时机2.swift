//
//  _122_买卖股票的最佳时机2.swift
//  Swift_Li
//
//  Created by lijianxin03 on 2022/1/5.
//

import Foundation

/*
 https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
 122. 买卖股票的最佳时机 II
 
 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 输入: prices = [7,1,5,3,6,4]
 输出: 7
 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3
 */

class Solution_122 {
    /*
     「贪心算法」 和 「动态规划」、「回溯搜索」 算法一样，完成一件事情，是 分步决策 的；
     「贪心算法」 在每一步总是做出在当前看来最好的选择，我是这样理解 「最好」 这两个字的意思：
     「最好」 的意思往往根据题目而来，可能是 「最小」，也可能是 「最大」；
     贪心算法和动态规划相比，它既不看前面（也就是说它不需要从前面的状态转移过来），也不看后面（无后效性，后面的选择不会对前面的选择有影响），因此贪心算法时间复杂度一般是线性的，空间复杂度是常数级别的；
     这道题 「贪心」 的地方在于，对于 「今天的股价 - 昨天的股价」，得到的结果有 3 种可能：① 正数，② 00，③负数。贪心算法的决策是： 只加正数 。
     */
    func maxProfit(_ prices: [Int]) -> Int {
        // 我们做的操作应该是买进昨天的，卖出今天的，虽然这种操作题目并不允许，但是它等价于：在下标为 0 的那一天买入，在下标为 3 的那一天卖出
        let len = prices.count
        if len < 2 {
            return 0
        }
        var res = 0
        for i in 1..<len {
            let diff = prices[i] - prices[i - 1]
            if diff > 0 {
                res += diff
            }
        }
        return res
    }
    
    /*
     动态规划
     */
    func maxProfit_dp(_ prices: [Int]) -> Int {
        /*
         状态 dp[i][j] 定义如下：
         dp[i][j] 表示到下标为 i 的这一天，持股状态为 j 时，我们手上拥有的最大现金数。
         */
        let len = prices.count
        if len < 2 {
            return 0
        }
        // 0 持有现金
        // 1 持有股票
        // 状态转移 0->1->0->1->0->1->0
        var dp = [[Int]](repeating: [Int](repeating: 0, count: 2), count: len)
        // 第一维 i 表示下标为 i 的那一天（ 具有前缀性质，即考虑了之前天数的交易 ）；
        // 第二维 j 表示下标为 i 的那一天是持有股票，还是持有现金。这里 0 表示持有现金（cash），1 表示持有股票（stock）
        
        // 起始的时候：
        dp[0][0] = 0 // 如果什么都不做，dp[0][0] = 0； 持有现金0
        dp[0][1] = -prices[0] // 如果持有股票，当前拥有的现金数是当天股价的相反数，即 dp[0][1] = -prices[i]；
        
        for i in 1..<len {
            /*
             考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即
             dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即dp[i−1][1]，这时候我们要将其卖出，并获得prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：
             */
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            /*
             再来考虑 dp[i][1]
             按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 dp[i−1][1]，或者前一天结束时还没有股票，即 dp[i−1][0]，这时候我们要将其买入，并减少
             prices[i] 的收益。可以列出如下的转移方程：
             */
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        }
        return dp[len - 1][0]  // 返回持有的现金
    }
}
